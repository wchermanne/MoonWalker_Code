//
//  Controllers_gr1.cpp
//
//
//  Created by William Chermanne on 27/02/17.
//
//


#include "MyIncludes_Moonwalker.h"
#include "MyIncludes_gr1.h"


#define RED   "\x1B[31m"
#define GRN   "\x1B[32m"
#define BLU   "\x1B[34m"
#define RESET "\x1B[0m"
#define MAG   "\x1B[35m"
#define CYN   "\x1B[36m"
//NAMESPACE_INIT(ctrlGr1); // where X should be replaced by your group number

/* This function initializes the StructControl structure
 *
 * param[in] : cvs controller main structure
 */

void StructControl_init(CtrlStruct *cvs) // Initialiser la structure controle
{
  cvs->struct_control->Kp = 0.0; //to be computed !!!!!
  cvs->struct_control->Ki = 0.0; //to be computed !!!!!
  cvs->struct_control->sum_error[0] = 0.0; // right wheel
  cvs->struct_control->sum_error[1] = 0.0; // left wheel
    cvs->struct_control->Speed_ref[0]=0.0;
    cvs->struct_control->Speed_ref[1]=0.0;


  cvs->struct_control->currentError[0] = 0.0;      // initial errors
  cvs->struct_control->currentError[1] = 0.0;
  cvs->struct_control->previousError[0] = 0.0;
  cvs->struct_control->previousError[1] = 0.0;
  cvs->struct_control->previousCommand[0] = 0.0;   // initial commands
  cvs->struct_control->previousCommand[1] = 0.0;
  cvs->struct_control->previousCommandLtd[0] = 0.0;
  cvs->struct_control->previousCommandLtd[1] = 0.0;


  cvs->struct_control->errDist = 1000; //to be computed !!!!!
  cvs->struct_control->errAngle = 1000; //to be computed !!!!!
  cvs->struct_control->counterNode=0;
  cvs->struct_control->command[0] = 0.0;
  cvs->struct_control->command[1] = 0.0;

  cvs->struct_control->Kt = 1.0;         // should not change
  cvs->struct_control->Tsample = 0.05;   // sampling period (1ms)

  cvs->struct_control->sum_error_dist = 0.0;
    cvs->struct_control->sum_error_angle = 0.0;
    cvs->struct_control->KiDist = 0.5;
    cvs->struct_control->KiAngle = 0.5;
    cvs->struct_control->prev_sum_error_dist = 1000;
    cvs->struct_control->prev_sum_error_dist_2 =1000;
    cvs->struct_control->counter =0;
    cvs->struct_control->isBlocked = 0;
    cvs->struct_control->t_blocked = 0;
    cvs->struct_control->isRotating= 0;

cvs->struct_control->lowlevelcommand0=0;
 cvs->struct_control->lowlevelcommand1=0;
cvs->struct_control->lowlevelKp=0;
cvs->struct_control->lowlevelKi=0;
 cvs->struct_control->middlelevelforwardspeed=0;
 cvs->struct_control->middlelevelrotatespeed=0;
cvs->struct_control->KpDist=0;
cvs->struct_control->KpAngle=0;

cvs->struct_control->Diffx=0;
cvs->struct_control->Diffy=0;
cvs->struct_control->emergencyStop=0;


}

void displayControllers(CtrlStruct *cvs)
{
    printf("Controllers!\n");
}


void Position_controller(CtrlStruct *cvs,double errDist, double errAngle,double KpDist, double KpAngle, double *command)
{
    cvs->struct_control->KpDist=KpDist;
    cvs->struct_control->KpAngle=KpAngle;
    // Commandes maximales recevables
    /*
    double maxV = 2.0;
    double maxW = 2.0;

    // Commande = min(max,commande)
    double commVrecue = KpDist*errDist;
    double commWrecue = KpAngle*errAngle;
    if(fabs(commVrecue) >= maxV){
        command[0]=maxV*getSign(commVrecue);
    }
    else{
        command[0]=KpDist*errDist;
    }
    if(fabs(commWrecue)>=maxW){
        command[1]=maxW*getSign(commWrecue);
    }
    else{
        command[1]=KpAngle*errAngle;
    }

    */
    if(errDist < 800 && (errAngle)>120*PI/180)
    {
        errDist=-errDist;
        errAngle = errAngle-PI;

    }
    else if(errDist < 800 && (errAngle)<-120*PI/180)
    {
        errDist=-errDist;
        errAngle = errAngle+PI;

    }

    command[0]=KpDist*errDist; // v
    command[1]=KpAngle*errAngle; // w

}


void FromHighToMiddleLevel(CtrlStruct *cvs,double *command)
{
double errDist;
  double errAngle;


  //printf("Entering From High to middle level\n");
  // Commande = ce qu'on retourne = [v,w]
  //double *command; // v,w
  //command= (double *)calloc(2,sizeof(double));
  Astar *A = cvs->struct_path_planning->astar;
  int counterNode=cvs->struct_control->counterNode;
  int length_path;
  int *path;

    path=A->path; // Path generated by A*
    length_path=A->length_path;


  if(counterNode<length_path)
{


    //printf(RED "CounterNode: %d \n" RESET,counterNode);

    // Position actuelle du robot
    double position_x=cvs->struct_odometry->x_t;
    double position_y=cvs->struct_odometry->y_t;

    printf("Position x: %f \n",position_x);
    printf("Position y: %f \n",position_y);

    double odo_angle=cvs->struct_odometry->theta_t;

    Node *nextNode;
    nextNode=A->map[path[counterNode]];
    cvs->struct_fsm->nextNodeIndex=nextNode->index;
    //Position du prochain noeud
    printf("Nextnode index: %d\n",nextNode->index);
    double nextPosition_x= nextNode ->x;
    double nextPosition_y= nextNode ->y;
     //tout droit si depart a PI/2
    //double nextPosition_x= 0;
    //double nextPosition_y= -100; // in mm



    double diffx= nextPosition_x-position_x;
    double diffy= nextPosition_y-position_y;
    cvs->struct_control->Diffx=diffx;
cvs->struct_control->Diffy=diffy;
     double arctan=atan2(diffy,diffx);
    if(arctan<0)
    {
      arctan+=2*PI;
    } // Remettre entre 0 et 2*PI

    if(odo_angle<0)
    {
      odo_angle+=2*PI;
    }
    if(arctan > odo_angle)
    {

      if(arctan - odo_angle > PI)
      {
        errAngle = (2*PI) -(arctan - odo_angle);
        errAngle = -errAngle;
      }
      else
      {
        errAngle = arctan - odo_angle;
      }
    }
    else
    {

      if(odo_angle - arctan > PI)
      {
        errAngle = (2*PI) -(odo_angle- arctan);
        errAngle = errAngle;
      }
      else
      {
        errAngle = odo_angle- arctan;
        errAngle = -errAngle;
      }
    }
    errDist = EuclidianDistance(nextPosition_x,nextPosition_y,position_x,position_y);
    printf("errDist:%f \n",errDist);
    cvs->struct_control->errDist=errDist;
    cvs->struct_control->errAngle=errAngle;

    if(errDist>DISTANCE_ERROR) // || fabs(errAngle)>5*PI/18)
    {

            Position_controller(cvs,errDist,errAngle,0.7, 1.5,command); // O.5 && 6
    }
    else
    {
        printf ("I AM IN ELSE");
      cvs->struct_control->sum_error_dist = 0.0;
      cvs->struct_control->sum_error_angle = 0.0;
      command[0]=0;
      command[1]=0;
      cvs->struct_control->counterNode++;
    }
  }
  else
  {
    command[0]=0;
    command[1]=0;
  }
}


/* This function computes the command to apply with a reference speed to follow
 *
 * param[in] : cvs controller main structure, table with speeds of the wheels
 * out : [xr,yr]
 */
void PI_controller(CtrlStruct *cvs, double *ref_speed, double Kp, double Ki, double*command)
{
    // memory allocation for the return value

    //command= (double *)calloc(2,sizeof(double));

    // calling for control structure => Ki, Kp, sum_error


    // current speed
    double curr_speed_right = cvs->inputs->r_wheel_speed;
    double curr_speed_left = cvs->inputs->l_wheel_speed;
    // errors
    cvs->struct_control->currentError[0] = ref_speed[0] - curr_speed_right;
    cvs->struct_control->currentError[1] = ref_speed[1] - curr_speed_left;

    // initializations and short names
    double command_right, command_left;
    double Tspl = cvs->struct_control->Tsample;
    double CerrR = cvs->struct_control->currentError[0];
    double CerrL = cvs->struct_control->currentError[1];
    double PerrR = cvs->struct_control->previousError[0];
    double PerrL = cvs->struct_control->previousError[1];
    double commR = cvs->struct_control->previousCommand[0];
    double commL = cvs->struct_control->previousCommand[1];
    double commLtdR = cvs->struct_control->previousCommandLtd[0];
    double commLtdL = cvs->struct_control->previousCommandLtd[1];
    double Kt = cvs->struct_control->Kt;

    command_right = ((Kp + Ki*Tspl)*CerrR - Kp*PerrR + Ki*Tspl*Kt*commLtdR + commR)/(Kt*Tspl*Ki + 1);
    command_left  = ((Kp + Ki*Tspl)*CerrL - Kp*PerrL + Ki*Tspl*Kt*commLtdL + commL)/(Kt*Tspl*Ki + 1);

    command[0] = command_right;
    command[1] = command_left;

    // assigning "previous" values to "current" ones
    cvs->struct_control->previousError[0] = CerrR;
    cvs->struct_control->previousError[1] = CerrL;
    cvs->struct_control->previousCommand[0] = command_right;
    cvs->struct_control->previousCommand[1] = command_left;
    cvs->struct_control->previousCommandLtd[0] = Limiter(command_right);
    cvs->struct_control->previousCommandLtd[1] = Limiter(command_left);
}

void LowLevelController(CtrlStruct *cvs, double *ref_speed, double Kp, double Ki, double *command)
{
    //printf("Entering Low Level controller\n");
    double u_left_prime, u_right_prime, kphi, K;
    kphi=26.1e-3;
    K =1;

    PI_controller(cvs,ref_speed,Kp,Ki,command); // Vient mettr dans commande la sortie du PI
    //printf("Low Level controller command 0: %f\n",command[0]);
    //printf("Low Level controller command 1: %f\n",command[1]);

    // limiter stage
    u_right_prime = Limiter(command[0]); // Vient
    u_left_prime = Limiter(command[1]);
    //printf("Low Level controller limiter 0: %f\n",command[0]);
    //printf("Low Level controller limiter 1: %f\n",command[1]);
    // Back EMF compenstation stages
    u_right_prime  = u_right_prime + (kphi/K)*(cvs->inputs->r_wheel_speed);
    u_left_prime = u_left_prime + (kphi/K)*(cvs->inputs->l_wheel_speed);


    // second limiter stage
    u_right_prime = Limiter(u_right_prime);
    u_left_prime = Limiter(u_left_prime);
    // variable assignation
    command[0] = u_right_prime; // Vient mettre dans commande les voltages
    command[1] = u_left_prime;
    cvs->struct_control->lowlevelKp=Kp;
    cvs->struct_control->lowlevelKi=Ki;

    cvs->struct_control->lowlevelcommand0=u_right_prime;
    cvs->struct_control->lowlevelcommand1=u_left_prime;


}


/* This function computes the command to each wheel with a reference vref and wref
 *
 * param[in] : cvs controller main structure, table with speeds of the wheels
 * out : [xr,yr]
 */
 void MiddleLevelController(CtrlStruct *cvs,double vref,double wref,double *Speed_ref)
{
    double l = 0.12; // In meters!
    double r = 0.03;


    double right_speed = (vref+l*wref)/r;
    double left_speed = (vref-l*wref)/r;

    Speed_ref[0] = right_speed;
    Speed_ref[1] = left_speed;

    cvs->struct_control->middlelevelforwardspeed=vref;
    cvs->struct_control->middlelevelrotatespeed=wref;

    cvs->struct_control->middlelevelcommand0=right_speed;
    cvs->struct_control->middlelevelcommand1=left_speed;

}

/*
 * Limiter block
 * => input : infinite range
 * => output bounded range between -100 and 100
 */

double Limiter(double input)
{
    double output;
    if(input >80)
    {
        output = 80;
    }
    else if(input < -80)
    {
        output = -80;
    }
    else
    {
        output = input;
    }
    return output;

}

/* computation of Kp and Ki for the low_level controller
 * designed for a Faulhaber 2342 024CR motor
 * assumption : T_electrical = 0
 *  output_0 = Kp; output_1 = Ki
 */
double *Kp_Ki_Computation(double overshoot, double time_response)
{
    double *output = (double*) malloc(sizeof(double)*2);

    double Ra =7.1; // résitance de l'induit
    double La=(0.265e-3); // inducantce de l'induit
    double kphi=26.1e-3;
    double J=0.58e-6;
    double Jrobot = 1.607e-5;
    double Kv=9.66e-6;
    double K = 1;

    double t_mechanical = (J+Jrobot)/Kv; // mechanical time constant
    double xsi = sqrt((CARRE(log(overshoot)))/((CARRE(PI))+ CARRE(log(overshoot))));
    double wn = 4/(xsi*time_response);
    double Ki = ((CARRE(wn))*Kv*Ra*t_mechanical)/(K*kphi);
    double Kp =((2*xsi*wn)*(Ra*Kv*t_mechanical) - Ra*Kv)/(K*kphi);

    output[0] = 14*Kp; // 14 is the reduction ratio
    output[1] = Ki;
    return output;

}

void IsBlocked(CtrlStruct *cvs)
{
  if((cvs->struct_control->prev_sum_error_dist- cvs->struct_control->prev_sum_error_dist_2) <= 0.02 && cvs->outputs->wheel_commands[R_ID] !=0 && cvs->outputs->wheel_commands[L_ID] !=0)
  {
    cvs->struct_control->counter++;
  }
  else
  {
    cvs->struct_control->counter =0;
  }
  if (cvs->struct_control->counter == 3000)
  {
    cvs->struct_control->isBlocked = 1;
    cvs->struct_control->counter = 0;
  }
}

/* ATTENTION A MODIFIERRRRRRRRR POUR RETOURNER UN TABLEAU DE DEUX????
*
*
*/

void StructControl_free(CtrlStruct *cvs)
{
  free(cvs->struct_control->sum_error);
}

